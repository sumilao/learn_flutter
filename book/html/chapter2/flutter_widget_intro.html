<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>2.2：Widget简介 - flutter实战（第二版）</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">flutter实战（第二版）</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="22--widget-简介"><a class="header" href="#22--widget-简介">2.2  Widget 简介</a></h1>
<h2 id="221-widget-概念"><a class="header" href="#221-widget-概念">2.2.1 Widget 概念</a></h2>
<p>在前面的介绍中，我们知道在Flutter中几乎所有的对象都是一个 widget 。与原生开发中“控件”不同的是，Flutter 中的 widget 的概念更广泛，它不仅可以表示UI元素，也可以表示一些功能性的组件如：用于手势检测的 <code>GestureDetector</code> 、用于APP主题数据传递的 <code>Theme</code> 等等，而原生开发中的控件通常只是指UI元素。在后面的内容中，我们在描述UI元素时可能会用到“控件”、“组件”这样的概念，读者心里需要知道他们就是 widget ，只是在不同场景的不同表述而已。由于 Flutter 主要就是用于构建用户界面的，所以，在大多数时候，读者可以认为 widget 就是一个控件，不必纠结于概念。</p>
<p>Flutter 中是通过 Widget 嵌套 Widget 的方式来构建UI和进行事件处理的，所以记住，Flutter 中万物皆为Widget。</p>
<h2 id="222--widget-接口"><a class="header" href="#222--widget-接口">2.2.2  Widget 接口</a></h2>
<p>在 Flutter 中， widget  的功能是“描述一个UI元素的配置信息”，它就是说， Widget 其实并不是表示最终绘制在设备屏幕上的显示元素，所谓的配置信息就是 Widget 接收的参数，比如对于 Text 来讲，文本的内容、对齐方式、文本样式都是它的配置信息。下面我们先来看一下 Widget 类的声明：</p>
<pre><code class="language-dart">@immutable // 不可变的
abstract class Widget extends DiagnosticableTree {
  const Widget({ this.key });

  final Key? key;

  @protected
  @factory
  Element createElement();

  @override
  String toStringShort() {
    final String type = objectRuntimeType(this, 'Widget');
    return key == null ? type : '$type-$key';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.defaultDiagnosticsTreeStyle = DiagnosticsTreeStyle.dense;
  }

  @override
  @nonVirtual
  bool operator ==(Object other) =&gt; super == other;

  @override
  @nonVirtual
  int get hashCode =&gt; super.hashCode;

  static bool canUpdate(Widget oldWidget, Widget newWidget) {
    return oldWidget.runtimeType == newWidget.runtimeType
        &amp;&amp; oldWidget.key == newWidget.key;
  }
  ...
}
</code></pre>
<ul>
<li><code>@immutable</code> 代表 Widget 是不可变的，这会限制 Widget 中定义的属性（即配置信息）必须是不可变的（final），为什么不允许 Widget 中定义的属性变化呢？这是因为，Flutter 中如果属性发生变化则会重新构建Widget树，即重新创建新的 Widget 实例来替换旧的 Widget 实例，所以允许 Widget 的属性变化是没有意义的，因为一旦 Widget 自己的属性变了自己就会被替换。这也是为什么 Widget 中定义的属性必须是 final 的原因。</li>
<li><code>widget</code>类继承自<code>DiagnosticableTree</code>，<code>DiagnosticableTree</code>即“诊断树”，主要作用是提供调试信息。</li>
<li><code>Key</code>: 这个<code>key</code>属性类似于 React/Vue 中的<code>key</code>，主要的作用是决定是否在下一次<code>build</code>时复用旧的 widget ，决定的条件在<code>canUpdate()</code>方法中。</li>
<li><code>createElement()</code>：正如前文所述“一个 widget 可以对应多个<code>Element</code>”；Flutter 框架在构建UI树时，会先调用此方法生成对应节点的<code>Element</code>对象。此方法是 Flutter 框架隐式调用的，在我们开发过程中基本不会调用到。</li>
<li><code>debugFillProperties(...)</code> 复写父类的方法，主要是设置诊断树的一些特性。</li>
<li><code>canUpdate(...)</code>是一个静态方法，它主要用于在 widget 树重新<code>build</code>时复用旧的  widget ，其实具体来说，应该是：是否用新的 widget 对象去更新旧UI树上所对应的<code>Element</code>对象的配置；通过其源码我们可以看到，只要<code>newWidget </code>与<code>oldWidget </code>的<code>runtimeType</code>和<code>key</code>同时相等时就会用<code>new widget </code>去更新<code>Element</code>对象的配置，否则就会创建新的<code>Element</code>。</li>
</ul>
<p>有关 Key 和 widget 复用的细节将会在本书后面高级部分深入讨论，读者现在只需知道，为 widget 显式添加 key 的话可能（但不一定）会使UI在重新构建时变的高效，读者目前可以先忽略此参数，本书后面在用到时会详细解释 。</p>
<p>另外<code>Widget</code>类本身是一个抽象类，其中最核心的就是定义了<code>createElement()</code>接口，在 Flutter 开发中，我们一般都不用直接继承<code>Widget</code>类来实现一个新组件，相反，我们通常会通过继承<code>StatelessWidget </code>或<code>StatefulWidget </code>来间接继承<code>widget</code>类来实现。<code>StatelessWidget </code>和<code>StatefulWidget </code>都是直接继承自<code>Widget</code>类，而这两个类也正是 Flutter 中非常重要的两个抽象类，它们引入了两种 widget 模型，接下来我们将重点介绍一下这两个类。</p>
<h2 id="223-flutter中的四棵树"><a class="header" href="#223-flutter中的四棵树">2.2.3 Flutter中的四棵树</a></h2>
<p>既然 Widget 只是描述一个UI元素的配置信息，那么真正的布局、绘制是由谁来完成的呢？Flutter 框架的处理流程是这样的：</p>
<ol>
<li>根据 Widget 树生成一个 Element 树，Element 树中的节点都继承自 <code>Element</code> 类。</li>
<li>根据 Element 树生成 Render 树（渲染树），渲染树中的节点都继承自<code> RenderObject</code> 类。</li>
<li>根据渲染树生成 Layer 树，然后上屏显示，Layer 树中的节点都继承自 <code>Layer</code> 类。</li>
</ol>
<p>真正的布局和渲染逻辑在 Render 树中，Element 是 Widget 和 RenderObject 的粘合剂，可以理解为一个中间代理。我们通过一个例子来说明，假设有如下 Widget 树：</p>
<pre><code class="language-dart">Container( // 一个容器 widget
  color: Colors.blue, // 设置容器背景色
  child: Row( // 可以将子widget沿水平方向排列
    children: [
      Image.network('https://www.example.com/1.png'), // 显示图片的 widget
      const Text('A'),
    ],
  ),
);
</code></pre>
<p>注意，如果 Container 设置了背景色，Container 内部会创建一个新的  ColoredBox 来填充背景，相关逻辑如下：</p>
<pre><code class="language-dart">if (color != null)
  current = ColoredBox(color: color!, child: current);
</code></pre>
<p>而 Image 内部会通过 RawImage 来渲染图片、Text 内部会通过 RichText 来渲染文本，所以最终的 Widget树、Element 树、渲染树结构如图2-2所示：</p>
<p><img src="../imgs/2-2.png" alt="图2-2" /></p>
<p>这里需要注意：</p>
<ol>
<li>三棵树中，Widget 和 Element 是一一对应的，但并不和 RenderObject 一一对应。比如 <code>StatelessWidget</code> 和 <code>StatefulWidget</code> 都没有对应的 RenderObject。</li>
<li>渲染树在上屏前会生成一棵 Layer 树，这个我们将在后面原理篇介绍，在前面的章节中读者只需要记住以上三棵树就行。</li>
</ol>
<h2 id="224-statelesswidget"><a class="header" href="#224-statelesswidget">2.2.4 StatelessWidget</a></h2>
<h3 id="1-简介"><a class="header" href="#1-简介">1. 简介</a></h3>
<p>在之前的章节中，我们已经简单介绍过<code>StatelessWidget </code>，<code>StatelessWidget </code>相对比较简单，它继承自<code>widget</code>类，重写了<code>createElement() </code>方法：</p>
<pre><code class="language-dart">@override
StatelessElement createElement() =&gt; StatelessElement(this);
</code></pre>
<p><code>StatelessElement</code> 间接继承自<code>Element</code>类，与<code>StatelessWidget </code>相对应（作为其配置数据）。</p>
<p><code>StatelessWidget </code>用于不需要维护状态的场景，它通常在<code>build</code>方法中通过嵌套其他 widget 来构建UI，在构建过程中会递归的构建其嵌套的 widget 。我们看一个简单的例子：</p>
<pre><code class="language-dart">class Echo extends StatelessWidget  {
  const Echo({
    Key? key,  
    required this.text,
    this.backgroundColor = Colors.grey, //默认为灰色
  }):super(key:key);
    
  final String text;
  final Color backgroundColor;

  @override
  Widget build(BuildContext context) {
    return Center(
      child: Container(
        color: backgroundColor,
        child: Text(text),
      ),
    );
  }
}
</code></pre>
<p>上面的代码，实现了一个回显字符串的<code>Echo</code>  widget 。</p>
<blockquote>
<p>按照惯例，widget 的构造函数参数应使用命名参数，命名参数中的必需要传的参数要添加<code>required</code>关键字，这样有利于静态代码分析器进行检查；在继承 widget 时，第一个参数通常应该是<code>Key</code>。另外，如果 widget 需要接收子 widget ，那么<code>child</code>或<code>children</code>参数通常应被放在参数列表的最后。同样是按照惯例， widget 的属性应尽可能的被声明为<code>final</code>，防止被意外改变。</p>
</blockquote>
<p>然后我们可以通过如下方式使用它：</p>
<pre><code class="language-dart"> Widget build(BuildContext context) {
  return Echo(text: "hello world");
}
</code></pre>
<p>运行后效果如图2-3所示：</p>
<p><img src="../imgs/2-3.png" alt="图2-3" /></p>
<h3 id="2-context"><a class="header" href="#2-context">2. Context</a></h3>
<p><code>build</code>方法有一个<code>context</code>参数，它是<code>BuildContext</code>类的一个实例，表示当前 widget 在 widget 树中的上下文，每一个 widget 都会对应一个 context 对象（因为每一个 widget 都是 widget 树上的一个节点）。实际上，<code>context</code>是当前 widget 在 widget 树中位置中执行”相关操作“的一个句柄(handle)，比如它提供了从当前 widget 开始向上遍历 widget 树以及按照 widget 类型查找父级 widget 的方法。下面是在子树中获取父级 widget 的一个示例：</p>
<pre><code class="language-dart">class ContextRoute extends StatelessWidget  {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text("Context测试"),
      ),
      body: Container(
        child: Builder(builder: (context) {
          // 在 widget 树中向上查找最近的父级`Scaffold`  widget 
          Scaffold scaffold = context.findAncestorWidgetOfExactType&lt;Scaffold&gt;();
          // 直接返回 AppBar的title， 此处实际上是Text("Context测试")
          return (scaffold.appBar as AppBar).title;
        }),
      ),
    );
  }
}
</code></pre>
<p>运行后效果如图2-4所示：</p>
<p><img src="../imgs/2-4.png" alt="图2-4" /></p>
<blockquote>
<p><strong>注意</strong>：对于<code>BuildContext</code>读者现在可以先作了解，随着本书后面内容的展开，也会用到 Context 的一些方法，读者可以通过具体的场景对其有个直观的认识。关于<code>BuildContext</code>更多的内容，我们也将在后面高级部分再深入介绍。</p>
</blockquote>
<h2 id="225-statefulwidget"><a class="header" href="#225-statefulwidget">2.2.5 StatefulWidget</a></h2>
<p>和<code>StatelessWidget </code>一样，<code>StatefulWidget</code>也是继承自<code>widget</code>类，并重写了<code>createElement() </code>方法，不同的是返回的<code>Element</code> 对象并不相同；另外<code>StatefulWidget</code>类中添加了一个新的接口<code>createState()</code>。</p>
<p>下面我们看看<code>StatefulWidget</code>的类定义：</p>
<pre><code class="language-dart">abstract class StatefulWidget extends Widget {
  const StatefulWidget({ Key key }) : super(key: key);
    
  @override
  StatefulElement createElement() =&gt; StatefulElement(this);
    
  @protected
  State createState();
}
</code></pre>
<ul>
<li>
<p><code>StatefulElement </code> 间接继承自<code>Element</code>类，与<code>StatefulWidget</code>相对应（作为其配置数据）。<code>StatefulElement </code>中可能会多次调用<code>createState()</code>来创建状态（State）对象。</p>
</li>
<li>
<p><code>createState()</code> 用于创建和 StatefulWidget 相关的状态，它在StatefulWidget 的生命周期中可能会被多次调用。例如，当一个 StatefulWidget 同时插入到 widget 树的多个位置时，Flutter 框架就会调用该方法为每一个位置生成一个独立的State实例，其实，本质上就是一个<code>StatefulElement</code>对应一个State实例。</p>
<blockquote>
<p>而在StatefulWidget 中，State 对象和<code>StatefulElement</code>具有一一对应的关系，所以在Flutter的SDK文档中，可以经常看到“从树中移除 State 对象”或“插入 State 对象到树中”这样的描述，此时的树指通过 widget 树生成的 Element 树。Flutter 的  SDK 文档中经常会提到“树” ，我们可以根据语境来判断到底指的是哪棵树。其实，无论是哪棵树，最终的目标都是为了描述 UI 的结构和绘制信息，所以在 Flutter 中遇到“树”的概念时，若无特别说明，我们都可以理解为 “一棵构成用户界面的节点树”，读者不必纠结于这些概念，还是那句话“得其神，忘其形”。</p>
</blockquote>
</li>
</ul>
<h2 id="226-state"><a class="header" href="#226-state">2.2.6 State</a></h2>
<h3 id="1-简介-1"><a class="header" href="#1-简介-1">1. 简介</a></h3>
<p>一个 StatefulWidget 类会对应一个 State 类，State表示与其对应的 StatefulWidget 要维护的状态，State 中的保存的状态信息可以：</p>
<ol>
<li>在 widget  构建时可以被同步读取。</li>
<li>在 widget 生命周期中可以被改变，当State被改变时，可以手动调用其<code>setState()</code>方法通知Flutter 框架状态发生改变，Flutter 框架在收到消息后，会重新调用其<code>build</code>方法重新构建 widget 树，从而达到更新UI的目的。</li>
</ol>
<p>State 中有两个常用属性：</p>
<ol>
<li>
<p><code>widget</code>，它表示与该 State 实例关联的 widget 实例，由Flutter 框架动态设置。注意，这种关联并非永久的，因为在应用生命周期中，UI树上的某一个节点的 widget 实例在重新构建时可能会变化，但State实例只会在第一次插入到树中时被创建，当在重新构建时，如果 widget 被修改了，Flutter 框架会动态设置State. widget 为新的 widget 实例。</p>
</li>
<li>
<p><code>context</code>。StatefulWidget对应的 BuildContext，作用同StatelessWidget 的BuildContext。</p>
</li>
</ol>
<h3 id="2-state生命周期"><a class="header" href="#2-state生命周期">2. State生命周期</a></h3>
<p>理解State的生命周期对flutter开发非常重要，为了加深读者印象，本节我们通过一个实例来演示一下 State 的生命周期。在接下来的示例中，我们仍然以计数器功能为例，实现一个计数器 CounterWidget 组件 ，点击它可以使计数器加1，由于要保存计数器的数值状态，所以我们应继承StatefulWidget，代码如下：</p>
<pre><code class="language-dart">class CounterWidget extends StatefulWidget {
  const CounterWidget({Key? key, this.initValue = 0});

  final int initValue;

  @override
  _CounterWidgetState createState() =&gt; _CounterWidgetState();
}
</code></pre>
<p><code>CounterWidget </code>接收一个<code>initValue</code>整型参数，它表示计数器的初始值。下面我们看一下State的代码：</p>
<pre><code class="language-dart">class _CounterWidgetState extends State&lt;CounterWidget&gt; {
  int _counter = 0;

  @override
  void initState() {
    super.initState();
    //初始化状态
    _counter = widget.initValue;
    print("initState");
  }

  @override
  Widget build(BuildContext context) {
    print("build");
    return Scaffold(
      body: Center(
        child: TextButton(
          child: Text('$_counter'),
          //点击后计数器自增
          onPressed: () =&gt; setState(
            () =&gt; ++_counter,
          ),
        ),
      ),
    );
  }

  @override
  void didUpdateWidget(CounterWidget oldWidget) {
    super.didUpdateWidget(oldWidget);
    print("didUpdateWidget ");
  }

  @override
  void deactivate() {
    super.deactivate();
    print("deactivate");
  }

  @override
  void dispose() {
    super.dispose();
    print("dispose");
  }

  @override
  void reassemble() {
    super.reassemble();
    print("reassemble");
  }

  @override
  void didChangeDependencies() {
    super.didChangeDependencies();
    print("didChangeDependencies");
  }
}
</code></pre>
<p>接下来，我们创建一个新路由，在新路由中，我们只显示一个<code>CounterWidget </code>：</p>
<pre><code class="language-dart">class StateLifecycleTest extends StatelessWidget {
  const StateLifecycleTest({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return CounterWidget();
  }
}
</code></pre>
<p>我们运行应用并打开该路由页面，在新路由页打开后，屏幕中央就会出现一个数字0，然后控制台日志输出：</p>
<pre><code class="language-shell">I/flutter ( 5436): initState
I/flutter ( 5436): didChangeDependencies
I/flutter ( 5436): build
</code></pre>
<p>可以看到，在StatefulWidget插入到 widget 树时首先<code>initState</code>方法会被调用。</p>
<p>然后我们点击⚡️按钮热重载，控制台输出日志如下：</p>
<pre><code class="language-shell">I/flutter ( 5436): reassemble
I/flutter ( 5436): didUpdateWidget 
I/flutter ( 5436): build
</code></pre>
<p>可以看到此时<code> initState</code> 和<code>didChangeDependencies</code>都没有被调用，而此时<code>didUpdateWidget </code>被调用。</p>
<p>接下来，我们在 widget 树中移除<code>CounterWidget </code>，将 StateLifecycleTest 的 <code>build </code>方法改为：</p>
<pre><code class="language-dart"> Widget build(BuildContext context) {
  //移除计数器 
  //return CounterWidget ();
  //随便返回一个Text()
  return Text("xxx");
}
</code></pre>
<p>然后热重载，日志如下：</p>
<pre><code class="language-shell">I/flutter ( 5436): reassemble
I/flutter ( 5436): deactive
I/flutter ( 5436): dispose
</code></pre>
<p>我们可以看到，在<code>CounterWidget </code>从 widget 树中移除时，<code>deactive</code>和<code>dispose</code>会依次被调用。</p>
<p>下面我们来看看各个回调函数：</p>
<ul>
<li>
<p><code>initState</code>：当 widget 第一次插入到 widget 树时会被调用，对于每一个State对象，Flutter 框架只会调用一次该回调，所以，通常在该回调中做一些一次性的操作，如状态初始化、订阅子树的事件通知等。不能在该回调中调用<code>BuildContext.dependOnInheritedWidgetOfExactType</code>（该方法用于在 widget 树上获取离当前 widget 最近的一个父级<code>InheritedWidget</code>，关于<code>InheritedWidget</code>我们将在后面章节介绍），原因是在初始化完成后， widget 树中的<code>InheritFrom widget </code>也可能会发生变化，所以正确的做法应该在在<code>build（）</code>方法或<code>didChangeDependencies()</code>中调用它。</p>
</li>
<li>
<p><code>didChangeDependencies()</code>：当State对象的依赖发生变化时会被调用；例如：在之前<code>build()</code> 中包含了一个<code>InheritedWidget </code> （第七章介绍），然后在之后的<code>build()</code> 中<code>Inherited widget </code>发生了变化，那么此时<code>InheritedWidget </code>的子 widget 的<code>didChangeDependencies()</code>回调都会被调用。典型的场景是当系统语言 Locale 或应用主题改变时，Flutter 框架会通知 widget 调用此回调。需要注意，组件第一次被创建后挂载的时候（包括重创建）对应的<code>didChangeDependencies</code>也会被调用。</p>
</li>
<li>
<p><code>build()</code>：此回调读者现在应该已经相当熟悉了，它主要是用于构建 widget 子树的，会在如下场景被调用：</p>
<ol>
<li>在调用<code>initState()</code>之后。</li>
<li>在调用<code>didUpdateWidget()</code>之后。</li>
<li>在调用<code>setState()</code>之后。</li>
<li>在调用<code>didChangeDependencies()</code>之后。</li>
<li>在State对象从树中一个位置移除后（会调用deactivate）又重新插入到树的其他位置之后。</li>
</ol>
</li>
<li>
<p><code>reassemble()</code>：此回调是专门为了开发调试而提供的，在热重载(hot reload)时会被调用，此回调在Release模式下永远不会被调用。</p>
</li>
<li>
<p><code>didUpdateWidget ()</code>：在 widget 重新构建时，Flutter 框架会调用<code> widget.canUpdate</code>来检测 widget 树中同一位置的新旧节点，然后决定是否需要更新，如果<code> widget.canUpdate</code>返回<code>true</code>则会调用此回调。正如之前所述，<code> widget.canUpdate</code>会在新旧 widget 的 <code>key</code> 和 <code>runtimeType</code> 同时相等时会返回true，也就是说在在新旧 widget 的key和runtimeType同时相等时<code>didUpdateWidget()</code>就会被调用。</p>
</li>
<li>
<p><code>deactivate()</code>：当 State 对象从树中被移除时，会调用此回调。在一些场景下，Flutter 框架会将 State 对象重新插到树中，如包含此 State 对象的子树在树的一个位置移动到另一个位置时（可以通过GlobalKey 来实现）。如果移除后没有重新插入到树中则紧接着会调用<code>dispose()</code>方法。</p>
</li>
<li>
<p><code>dispose()</code>：当 State 对象从树中被永久移除时调用；通常在此回调中释放资源。</p>
</li>
</ul>
<p>StatefulWidget 生命周期如图2-5所示：</p>
<p><img src="../imgs/2-5.jpg" alt="图2-5" /></p>
<blockquote>
<p><strong>注意</strong>：在继承<code>StatefulWidget</code>重写其方法时，对于包含<code>@mustCallSuper</code>标注的父类方法，都要在子类方法中调用父类方法。</p>
</blockquote>
<h2 id="227-在-widget-树中获取state对象"><a class="header" href="#227-在-widget-树中获取state对象">2.2.7 在 widget 树中获取State对象</a></h2>
<p>由于 StatefulWidget 的具体逻辑都在其 State 中，所以很多时候，我们需要获取 StatefulWidget 对应的State 对象来调用一些方法，比如<code>Scaffold</code>组件对应的状态类<code>ScaffoldState</code>中就定义了打开 SnackBar（路由页底部提示条）的方法。我们有两种方法在子 widget 树中获取父级 StatefulWidget 的State 对象。</p>
<h3 id="1-通过context获取"><a class="header" href="#1-通过context获取">1. 通过Context获取</a></h3>
<p><code>context</code>对象有一个<code>findAncestorStateOfType()</code>方法，该方法可以从当前节点沿着 widget 树向上查找指定类型的 StatefulWidget 对应的 State 对象。下面是实现打开 SnackBar 的示例：</p>
<pre><code class="language-dart">class GetStateObjectRoute extends StatefulWidget {
  const GetStateObjectRoute({Key? key}) : super(key: key);

  @override
  State&lt;GetStateObjectRoute&gt; createState() =&gt; _GetStateObjectRouteState();
}

class _GetStateObjectRouteState extends State&lt;GetStateObjectRoute&gt; {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: Text("子树中获取State对象"),
      ),
      body: Center(
        child: Column(
          children: [
            Builder(builder: (context) {
              return ElevatedButton(
                onPressed: () {
                  // 查找父级最近的Scaffold对应的ScaffoldState对象
                  ScaffoldState _state = context.findAncestorStateOfType&lt;ScaffoldState&gt;()!;
                  // 打开抽屉菜单
                  _state.openDrawer();
                },
                child: Text('打开抽屉菜单1'),
              );
            }),
          ],
        ),
      ),
      drawer: Drawer(),
    );
  }
}
</code></pre>
<p>一般来说，如果 StatefulWidget 的状态是私有的（不应该向外部暴露），那么我们代码中就不应该去直接获取其 State 对象；如果StatefulWidget的状态是希望暴露出的（通常还有一些组件的操作方法），我们则可以去直接获取其State对象。但是通过 <code>context.findAncestorStateOfType</code> 获取 StatefulWidget 的状态的方法是通用的，我们并不能在语法层面指定 StatefulWidget 的状态是否私有，所以在 Flutter 开发中便有了一个默认的约定：如果 StatefulWidget 的状态是希望暴露出的，应当在 StatefulWidget 中提供一个<code>of</code> 静态方法来获取其 State 对象，开发者便可直接通过该方法来获取；如果 State不希望暴露，则不提供<code>of</code>方法。这个约定在 Flutter SDK 里随处可见。所以，上面示例中的<code>Scaffold</code>也提供了一个<code>of</code>方法，我们其实是可以直接调用它的：</p>
<pre><code class="language-dart">Builder(builder: (context) {
  return ElevatedButton(
    onPressed: () {
      // 直接通过of静态方法来获取ScaffoldState
      ScaffoldState _state=Scaffold.of(context);
      // 打开抽屉菜单
      _state.openDrawer();
    },
    child: Text('打开抽屉菜单2'),
  );
}),
</code></pre>
<p>又比如我们想显示 snack bar 的话可以通过下面代码调用：</p>
<pre><code class="language-dart">Builder(builder: (context) {
  return ElevatedButton(
    onPressed: () {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(content: Text("我是SnackBar")),
      );
    },
    child: Text('显示SnackBar'),
  );
}),
</code></pre>
<p>上面示例运行后，点击”显示SnackBar“，效果如图2-6所示：</p>
<p><img src="../imgs/2-6.png" alt="图2-6" /></p>
<h3 id="2-通过globalkey"><a class="header" href="#2-通过globalkey">2. 通过GlobalKey</a></h3>
<p>Flutter还有一种通用的获取<code>State</code>对象的方法——通过GlobalKey来获取！ 步骤分两步：</p>
<ol>
<li>
<p>给目标<code>StatefulWidget</code>添加<code>GlobalKey</code>。</p>
<pre><code class="language-dart">//定义一个globalKey, 由于GlobalKey要保持全局唯一性，我们使用静态变量存储
static GlobalKey&lt;ScaffoldState&gt; _globalKey= GlobalKey();
...
Scaffold(
    key: _globalKey , //设置key
    ...  
)
</code></pre>
</li>
<li>
<p>通过<code>GlobalKey</code>来获取<code>State</code>对象</p>
<pre><code class="language-dart">_globalKey.currentState.openDrawer()
</code></pre>
</li>
</ol>
<p>GlobalKey 是 Flutter 提供的一种在整个 App 中引用 element 的机制。如果一个 widget 设置了<code>GlobalKey</code>，那么我们便可以通过<code>globalKey.currentWidget </code>获得该 widget 对象、<code>globalKey.currentElement</code>来获得 widget 对应的element对象，如果当前 widget 是<code>StatefulWidget</code>，则可以通过<code>globalKey.currentState</code>来获得该 widget 对应的state对象。</p>
<blockquote>
<p>注意：使用 GlobalKey 开销较大，如果有其他可选方案，应尽量避免使用它。另外，同一个 GlobalKey 在整个 widget 树中必须是唯一的，不能重复。</p>
</blockquote>
<h2 id="228-通过-renderobject-自定义-widget"><a class="header" href="#228-通过-renderobject-自定义-widget">2.2.8 通过 RenderObject 自定义 Widget</a></h2>
<p><code>StatelessWidget</code> 和 <code>StatefulWidget</code> 都是用于组合其他组件的，它们本身没有对应的 RenderObject。Flutter 组件库中的很多基础组件都不是通过<code>StatelessWidget</code> 和 <code>StatefulWidget</code> 来实现的，比如 Text 、Column、Align等，就好比搭积木，<code>StatelessWidget</code> 和 <code>StatefulWidget</code> 可以将积木搭成不同的样子，但前提是得有积木，而这些积木都是通过自定义 RenderObject 来实现的。实际上Flutter 最原始的定义组件的方式就是通过定义RenderObject 来实现，而<code>StatelessWidget</code> 和 <code>StatefulWidget</code> 只是提供的两个帮助类。下面我们简单演示一下通过RenderObject定义组件的方式：</p>
<pre><code class="language-dart">class CustomWidget extends LeafRenderObjectWidget{
  @override
  RenderObject createRenderObject(BuildContext context) {
    // 创建 RenderObject
    return RenderCustomObject();
  }
  @override
  void updateRenderObject(BuildContext context, RenderCustomObject  renderObject) {
    // 更新 RenderObject
    super.updateRenderObject(context, renderObject);
  }
}

class RenderCustomObject extends RenderBox{

  @override
  void performLayout() {
    // 实现布局逻辑
  }

  @override
  void paint(PaintingContext context, Offset offset) {
    // 实现绘制
  }
}
</code></pre>
<p>如果组件不会包含子组件，则我们可以直接继承自 LeafRenderObjectWidget ，它是 RenderObjectWidget 的子类，而 RenderObjectWidget 继承自 Widget ，我们可以看一下它的实现：</p>
<pre><code class="language-dart">abstract class LeafRenderObjectWidget extends RenderObjectWidget {
  const LeafRenderObjectWidget({ Key? key }) : super(key: key);

  @override
  LeafRenderObjectElement createElement() =&gt; LeafRenderObjectElement(this);
}
</code></pre>
<p>很简单，就是帮 widget 实现了createElement 方法，它会为组件创建一个 类型为 LeafRenderObjectElement 的 Element对象。如果自定义的 widget 可以包含子组件，则可以根据子组件的数量来选择继承SingleChildRenderObjectWidget 或 MultiChildRenderObjectWidget，它们也实现了createElement() 方法，返回不同类型的 Element 对象。</p>
<p>然后我们重写了 createRenderObject 方法，它是 RenderObjectWidget 中定义方法，该方法被组件对应的 Element 调用（构建渲染树时）用于生成渲染对象。我们的主要任务就是来实现 createRenderObject  返回的渲染对象类，本例中是 RenderCustomObject 。updateRenderObject 方法是用于在组件树状态发生变化但不需要重新创建 RenderObject 时用于更新组件渲染对象的回调。</p>
<p>RenderCustomObject 类是继承自 RenderBox，而 RenderBox 继承自 RenderObject，我们需要在 RenderCustomObject 中实现布局、绘制、事件响应等逻辑，关于如何实现这些逻辑，涉及到的知识点会贯穿本书，现在先不要着急，我们会在后面的章节中逐步介绍。</p>
<h2 id="229-flutter-sdk内置组件库介绍"><a class="header" href="#229-flutter-sdk内置组件库介绍">2.2.9 Flutter SDK内置组件库介绍</a></h2>
<p>Flutter 提供了一套丰富、强大的基础组件，在基础组件库之上 Flutter 又提供了一套 Material 风格（ Android 默认的视觉风格）和一套 Cupertino 风格（iOS视觉风格）的组件库。要使用基础组件库，需要先导入：</p>
<pre><code class="language-dart">import 'package:flutter/widgets.dart';
</code></pre>
<p>下面我们介绍一下常用的组件。</p>
<h3 id="1-基础组件"><a class="header" href="#1-基础组件">1. 基础组件</a></h3>
<ul>
<li><a href="https://docs.flutter.dev/flutter/widgets/Text-class.html"><code>Text</code></a>：该组件可让您创建一个带格式的文本。</li>
<li><a href="https://docs.flutter.dev/flutter/widgets/Row-class.html"><code>Row</code></a>、 <a href="https://docs.flutter.dev/flutter/widgets/Column-class.html"><code>Column</code></a>： 这些具有弹性空间的布局类 widget 可让您在水平（Row）和垂直（Column）方向上创建灵活的布局。其设计是基于 Web 开发中的 Flexbox 布局模型。</li>
<li><a href="https://docs.flutter.dev/flutter/widgets/Stack-class.html"><code>Stack</code></a>： 取代线性布局 (译者语：和 Android 中的<code>FrameLayout</code>相似)，[<code>Stack</code>](https://docs.flutter.dev/flutter/ widgets/Stack-class.html)允许子 widget 堆叠， 你可以使用 <a href="https://docs.flutter.dev/flutter/widgets/Positioned-class.html"><code>Positioned</code></a> 来定位他们相对于<code>Stack</code>的上下左右四条边的位置。Stacks是基于Web开发中的绝对定位（absolute positioning )布局模型设计的。</li>
<li><a href="https://docs.flutter.dev/flutter/widgets/Container-class.html"><code>Container</code></a>： <a href="https://docs.flutter.dev/flutter/widgets/Container-class.html"><code>Container</code></a> 可让您创建矩形视觉元素。Container 可以装饰一个<a href="https://docs.flutter.dev/flutter/painting/BoxDecoration-class.html"><code>BoxDecoration</code></a>, 如 background、一个边框、或者一个阴影。 <a href="https://docs.flutter.dev/flutter/widgets/Container-class.html"><code>Container</code></a> 也可以具有边距（margins）、填充(padding)和应用于其大小的约束(constraints)。另外， <a href="https://docs.flutter.dev/flutter/widgets/Container-class.html"><code>Container</code></a>可以使用矩阵在三维空间中对其进行变换。</li>
</ul>
<h3 id="2-material组件"><a class="header" href="#2-material组件">2. Material组件</a></h3>
<p>Flutter 提供了一套丰富 的Material 组件，它可以帮助我们构建遵循 Material Design 设计规范的应用程序。Material 应用程序以<a href="https://docs.flutter.dev/flutter/material/MaterialApp-class.html"><code>MaterialApp</code></a> 组件开始， 该组件在应用程序的根部创建了一些必要的组件，比如<code>Theme</code>组件，它用于配置应用的主题。 是否使用<a href="https://docs.flutter.dev/flutter/material/MaterialApp-class.html"><code>MaterialApp</code></a>完全是可选的，但是使用它是一个很好的做法。在之前的示例中，我们已经使用过多个 Material 组件了，如：<code>Scaffold</code>、<code>AppBar</code>、<code>TextButton</code>等。要使用 Material 组件，需要先引入它：</p>
<pre><code class="language-dart">import 'package:flutter/material.dart';
</code></pre>
<h3 id="3-cupertino组件"><a class="header" href="#3-cupertino组件">3. Cupertino组件</a></h3>
<p>Flutter 也提供了一套丰富的 Cupertino 风格的组件，尽管目前还没有 Material 组件那么丰富，但是它仍在不断的完善中。值得一提的是在 Material 组件库中有一些组件可以根据实际运行平台来切换表现风格，比如<code>MaterialPageRoute</code>，在路由切换时，如果是 Android 系统，它将会使用 Android 系统默认的页面切换动画(从底向上)；如果是 iOS 系统，它会使用 iOS 系统默认的页面切换动画（从右向左）。由于在前面的示例中还没有Cupertino组件的示例，下面我们实现一个简单的 Cupertino 组件风格的页面：</p>
<pre><code class="language-dart">//导入cupertino  widget 库
import 'package:flutter/cupertino.dart';

class CupertinoTestRoute extends StatelessWidget  {
  const CupertinoTestRoute({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return CupertinoPageScaffold(
      navigationBar: const CupertinoNavigationBar(
        middle: Text("Cupertino Demo"),
      ),
      child: Center(
        child: CupertinoButton(
            color: CupertinoColors.activeBlue,
            child: const Text("Press"),
            onPressed: () {}
        ),
      ),
    );
  }
}
</code></pre>
<p>下面（图2-7）是在iPhoneX上页面效果截图：</p>
<p><img src="../imgs/2-7.png" alt="图2-7" /></p>
<h2 id="2210-总结"><a class="header" href="#2210-总结">2.2.10 总结</a></h2>
<p>Flutter 的 widget 类型分为<code>StatefulWidget</code> 和 <code>StatelessWidget</code> 两种，读者需要深入理解它们的区别，widget 将是我们构建Flutter应用的基石。</p>
<p>Flutter 提供了丰富的组件，在实际的开发中我们可以根据需要随意使用它们，而不必担心引入过多组件库会让你的应用安装包变大，这不是 web 开发，dart 在编译时只会编译你使用了的代码。由于 Material 和 Cupertino 都是在基础组件库之上的，所以如果我们的应用中引入了这两者之一，则不需要再引入<code>flutter/ widgets.dart</code>了，因为它们内部已经引入过了。</p>
<p>另外需要说明一点，本章后面章节的示例中会使用一些布局类组件，如<code>Scaffold</code>、<code>Row</code>、<code>Column</code>等，这些组件将在后面“布局类组件”一章中详细介绍，读者可以先不用关注。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapter2/first_flutter_app.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chapter2/state_manage.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapter2/first_flutter_app.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chapter2/state_manage.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
