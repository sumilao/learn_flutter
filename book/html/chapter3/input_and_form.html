<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>3.5：输入框及表单 - flutter实战（第二版）</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">flutter实战（第二版）</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="35-输入框及表单"><a class="header" href="#35-输入框及表单">3.5 输入框及表单</a></h1>
<p>Material 组件库中提供了输入框组件<code>TextField</code>和表单组件<code>Form</code>。下面我们分别介绍一下。</p>
<h2 id="351-textfield"><a class="header" href="#351-textfield">3.5.1 TextField</a></h2>
<p><code>TextField</code>用于文本输入，它提供了很多属性，我们先简单介绍一下主要属性的作用，然后通过几个示例来演示一下关键属性的用法。</p>
<pre><code class="language-dart">const TextField({
  ...
  TextEditingController controller, 
  FocusNode focusNode,
  InputDecoration decoration = const InputDecoration(),
  TextInputType keyboardType,
  TextInputAction textInputAction,
  TextStyle style,
  TextAlign textAlign = TextAlign.start,
  bool autofocus = false,
  bool obscureText = false,
  int maxLines = 1,
  int maxLength,
  this.maxLengthEnforcement,
  ToolbarOptions? toolbarOptions,
  ValueChanged&lt;String&gt; onChanged,
  VoidCallback onEditingComplete,
  ValueChanged&lt;String&gt; onSubmitted,
  List&lt;TextInputFormatter&gt; inputFormatters,
  bool enabled,
  this.cursorWidth = 2.0,
  this.cursorRadius,
  this.cursorColor,
  this.onTap,
  ...
})
</code></pre>
<ul>
<li>
<p><code>controller</code>：编辑框的控制器，通过它可以设置/获取编辑框的内容、选择编辑内容、监听编辑文本改变事件。大多数情况下我们都需要显式提供一个<code>controller</code>来与文本框交互。如果没有提供<code>controller</code>，则<code>TextField</code>内部会自动创建一个。</p>
</li>
<li>
<p><code>focusNode</code>：用于控制<code>TextField</code>是否占有当前键盘的输入焦点。它是我们和键盘交互的一个句柄（handle）。</p>
</li>
<li>
<p><code>InputDecoration</code>：用于控制<code>TextField</code>的外观显示，如提示文本、背景颜色、边框等。</p>
</li>
<li>
<p><code>keyboardType</code>：用于设置该输入框默认的键盘输入类型，取值如下：</p>
<div class="table-wrapper"><table><thead><tr><th>TextInputType枚举值</th><th>含义</th></tr></thead><tbody>
<tr><td>text</td><td>文本输入键盘</td></tr>
<tr><td>multiline</td><td>多行文本，需和maxLines配合使用(设为null或大于1)</td></tr>
<tr><td>number</td><td>数字；会弹出数字键盘</td></tr>
<tr><td>phone</td><td>优化后的电话号码输入键盘；会弹出数字键盘并显示“* #”</td></tr>
<tr><td>datetime</td><td>优化后的日期输入键盘；Android上会显示“: -”</td></tr>
<tr><td>emailAddress</td><td>优化后的电子邮件地址；会显示“@ .”</td></tr>
<tr><td>url</td><td>优化后的url输入键盘； 会显示“/ .”</td></tr>
</tbody></table>
</div></li>
<li>
<p><code>textInputAction</code>：键盘动作按钮图标(即回车键位图标)，它是一个枚举值，有多个可选值，全部的取值列表读者可以查看API文档，下面是当值为<code>TextInputAction.search</code>时，原生Android系统下键盘样式如图3-18所示：</p>
<p><img src="../imgs/3-18.png" alt="图3-18" /></p>
</li>
<li>
<p><code>style</code>：正在编辑的文本样式。</p>
</li>
<li>
<p><code>textAlign</code>: 输入框内编辑文本在水平方向的对齐方式。</p>
</li>
<li>
<p><code>autofocus</code>: 是否自动获取焦点。</p>
</li>
<li>
<p><code>obscureText</code>：是否隐藏正在编辑的文本，如用于输入密码的场景等，文本内容会用“•”替换。</p>
</li>
<li>
<p><code>maxLines</code>：输入框的最大行数，默认为1；如果为<code>null</code>，则无行数限制。</p>
</li>
<li>
<p><code>maxLength</code>和<code>maxLengthEnforcement</code> ：<code>maxLength</code>代表输入框文本的最大长度，设置后输入框右下角会显示输入的文本计数。<code>maxLengthEnforcement</code>决定当输入文本长度超过<code>maxLength</code>时如何处理，如截断、超出等。</p>
</li>
<li>
<p><code>toolbarOptions</code>：长按或鼠标右击时出现的菜单，包括 copy、cut、paste 以及 selectAll。</p>
</li>
<li>
<p><code>onChange</code>：输入框内容改变时的回调函数；注：内容改变事件也可以通过<code>controller</code>来监听。</p>
</li>
<li>
<p><code>onEditingComplete</code>和<code>onSubmitted</code>：这两个回调都是在输入框输入完成时触发，比如按了键盘的完成键（对号图标）或搜索键（🔍图标）。不同的是两个回调签名不同，<code>onSubmitted</code>回调是<code>ValueChanged&lt;String&gt;</code>类型，它接收当前输入内容做为参数，而<code>onEditingComplete</code>不接收参数。</p>
</li>
<li>
<p><code>inputFormatters</code>：用于指定输入格式；当用户输入内容改变时，会根据指定的格式来校验。</p>
</li>
<li>
<p><code>enable</code>：如果为<code>false</code>，则输入框会被禁用，禁用状态不能响应输入和事件，同时显示禁用态样式（在其<code>decoration</code>中定义）。</p>
</li>
<li>
<p><code>cursorWidth</code>、<code>cursorRadius</code>和<code>cursorColor</code>：这三个属性是用于自定义输入框光标宽度、圆角和颜色的。</p>
</li>
</ul>
<h3 id="1-示例登录输入框"><a class="header" href="#1-示例登录输入框">1. 示例：登录输入框</a></h3>
<h4 id="1布局"><a class="header" href="#1布局">1）布局</a></h4>
<p>我们实现一个登录表单：</p>
<pre><code class="language-dart">Column(
  children: &lt;Widget&gt;[
    TextField(
      autofocus: true,
      decoration: InputDecoration(
        labelText: "用户名",
        hintText: "用户名或邮箱",
        prefixIcon: Icon(Icons.person)
      ),
    ),
    TextField(
      decoration: InputDecoration(
        labelText: "密码",
        hintText: "您的登录密码",
        prefixIcon: Icon(Icons.lock)
      ),
      obscureText: true,
    ),
  ],
);
</code></pre>
<p>运行后，效果如图3-19所示：</p>
<p><img src="../imgs/3-19.png" alt="图3-19" /></p>
<h4 id="2获取输入内容"><a class="header" href="#2获取输入内容">2）获取输入内容</a></h4>
<p>获取输入内容有两种方式：</p>
<ol>
<li>定义两个变量，用于保存用户名和密码，然后在<code>onChange</code>触发时，各自保存一下输入内容。</li>
<li>通过<code>controller</code>直接获取。</li>
</ol>
<p>第一种方式比较简单，不在举例，我们来重点看一下第二种方式，我们以用户名输入框举例：</p>
<p>定义一个<code>controller</code>：</p>
<pre><code class="language-dart">//定义一个controller
TextEditingController _unameController = TextEditingController();
</code></pre>
<p>然后设置输入框controller：</p>
<pre><code class="language-dart">TextField(
    autofocus: true,
    controller: _unameController, //设置controller
    ...
)
</code></pre>
<p>通过controller获取输入框内容</p>
<pre><code class="language-dart">print(_unameController.text)
</code></pre>
<h4 id="3监听文本变化"><a class="header" href="#3监听文本变化">3）监听文本变化</a></h4>
<p>监听文本变化也有两种方式：</p>
<ol>
<li>
<p>设置<code>onChange</code>回调，如：</p>
<pre><code class="language-dart">TextField(
    autofocus: true,
    onChanged: (v) {
      print("onChange: $v");
    }
)
</code></pre>
</li>
<li>
<p>通过<code>controller</code>监听，如：</p>
<pre><code class="language-dart">@override
void initState() {
  //监听输入改变  
  _unameController.addListener((){
    print(_unameController.text);
  });
}
</code></pre>
</li>
</ol>
<p>两种方式相比，<code>onChanged</code>是专门用于监听文本变化，而<code>controller</code>的功能却多一些，除了能监听文本变化外，它还可以设置默认值、选择文本，下面我们看一个例子：</p>
<p>创建一个<code>controller</code>:</p>
<pre><code class="language-dart">TextEditingController _selectionController =  TextEditingController();
</code></pre>
<p>设置默认值，并从第三个字符开始选中后面的字符</p>
<pre><code class="language-dart">_selectionController.text="hello world!";
_selectionController.selection=TextSelection(
    baseOffset: 2,
    extentOffset: _selectionController.text.length
);
</code></pre>
<p>设置<code>controller</code>:</p>
<pre><code class="language-dart">TextField(
  controller: _selectionController,
)
</code></pre>
<p>运行效果如图3-20所示：</p>
<p><img src="../imgs/3-20.png" alt="图3-20" /></p>
<h4 id="4控制焦点"><a class="header" href="#4控制焦点">4）控制焦点</a></h4>
<p>焦点可以通过<code>FocusNode</code>和<code>FocusScopeNode</code>来控制，默认情况下，焦点由<code>FocusScope</code>来管理，它代表焦点控制范围，可以在这个范围内可以通过<code>FocusScopeNode</code>在输入框之间移动焦点、设置默认焦点等。我们可以通过<code>FocusScope.of(context)</code> 来获取Widget树中默认的<code>FocusScopeNode</code>。下面看一个示例，在此示例中创建两个<code>TextField</code>，第一个自动获取焦点，然后创建两个按钮：</p>
<ul>
<li>点击第一个按钮可以将焦点从第一个<code>TextField</code>挪到第二个<code>TextField</code>。</li>
<li>点击第二个按钮可以关闭键盘。</li>
</ul>
<p>我们要实现的效果如图3-21所示：</p>
<p><img src="../imgs/3-21.png" alt="图3-21" /></p>
<p>代码如下：</p>
<pre><code class="language-dart">class FocusTestRoute extends StatefulWidget {
  @override
  _FocusTestRouteState createState() =&gt; _FocusTestRouteState();
}

class _FocusTestRouteState extends State&lt;FocusTestRoute&gt; {
  FocusNode focusNode1 = FocusNode();
  FocusNode focusNode2 = FocusNode();
  FocusScopeNode? focusScopeNode;

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: EdgeInsets.all(16.0),
      child: Column(
        children: &lt;Widget&gt;[
          TextField(
            autofocus: true, 
            focusNode: focusNode1,//关联focusNode1
            decoration: InputDecoration(
                labelText: "input1"
            ),
          ),
          TextField(
            focusNode: focusNode2,//关联focusNode2
            decoration: InputDecoration(
                labelText: "input2"
            ),
          ),
          Builder(builder: (ctx) {
            return Column(
              children: &lt;Widget&gt;[
                ElevatedButton(
                  child: Text("移动焦点"),
                  onPressed: () {
                    //将焦点从第一个TextField移到第二个TextField
                    // 这是一种写法 FocusScope.of(context).requestFocus(focusNode2);
                    // 这是第二种写法
                    if(null == focusScopeNode){
                      focusScopeNode = FocusScope.of(context);
                    }
                    focusScopeNode.requestFocus(focusNode2);
                  },
                ),
                ElevatedButton(
                  child: Text("隐藏键盘"),
                  onPressed: () {
                    // 当所有编辑框都失去焦点时键盘就会收起  
                    focusNode1.unfocus();
                    focusNode2.unfocus();
                  },
                ),
              ],
            );
          },
          ),
        ],
      ),
    );
  }

}
</code></pre>
<p><code>FocusNode</code>和<code>FocusScopeNode</code>还有一些其他的方法，详情可以查看API文档。</p>
<h4 id="5监听焦点状态改变事件"><a class="header" href="#5监听焦点状态改变事件">5）监听焦点状态改变事件</a></h4>
<p><code>FocusNode</code>继承自<code>ChangeNotifier</code>，通过<code>FocusNode</code>可以监听焦点的改变事件，如：</p>
<pre><code class="language-dart">...
// 创建 focusNode   
FocusNode focusNode = FocusNode();
...
// focusNode绑定输入框   
TextField(focusNode: focusNode);
...
// 监听焦点变化    
focusNode.addListener((){
   print(focusNode.hasFocus);
});
</code></pre>
<p>获得焦点时<code>focusNode.hasFocus</code>值为<code>true</code>，失去焦点时为<code>false</code>。</p>
<h4 id="6自定义样式"><a class="header" href="#6自定义样式">6）自定义样式</a></h4>
<p>虽然我们可以通过<code>decoration</code>属性来定义输入框样式，下面以自定义输入框下划线颜色为例来介绍一下：</p>
<pre><code class="language-dart">TextField(
  decoration: InputDecoration(
    labelText: "请输入用户名",
    prefixIcon: Icon(Icons.person),
    // 未获得焦点下划线设为灰色
    enabledBorder: UnderlineInputBorder(
      borderSide: BorderSide(color: Colors.grey),
    ),
    //获得焦点下划线设为蓝色
    focusedBorder: UnderlineInputBorder(
      borderSide: BorderSide(color: Colors.blue),
    ),
  ),
),
</code></pre>
<p>上面代码我们直接通过InputDecoration的enabledBorder和focusedBorder来分别设置了输入框在未获取焦点和获得焦点后的下划线颜色。另外，我们也可以通过主题来自定义输入框的样式，下面我们探索一下如何在不使用enabledBorder和focusedBorder的情况下来自定义下滑线颜色。</p>
<p>由于<code>TextField</code>在绘制下划线时使用的颜色是主题色里面的<code>hintColor</code>，但提示文本颜色也是用的<code>hintColor</code>， 如果我们直接修改<code>hintColor</code>，那么下划线和提示文本的颜色都会变。值得高兴的是<code>decoration</code>中可以设置<code>hintStyle</code>，它可以覆盖<code>hintColor</code>，并且主题中可以通过<code>inputDecorationTheme</code>来设置输入框默认的<code>decoration</code>。所以我们可以通过主题来自定义，代码如下：</p>
<pre><code class="language-dart">Theme(
  data: Theme.of(context).copyWith(
      hintColor: Colors.grey[200], //定义下划线颜色
      inputDecorationTheme: InputDecorationTheme(
          labelStyle: TextStyle(color: Colors.grey),//定义label字体样式
          hintStyle: TextStyle(color: Colors.grey, fontSize: 14.0)//定义提示文本样式
      )
  ),
  child: Column(
    children: &lt;Widget&gt;[
      TextField(
        decoration: InputDecoration(
            labelText: "用户名",
            hintText: "用户名或邮箱",
            prefixIcon: Icon(Icons.person)
        ),
      ),
      TextField(
        decoration: InputDecoration(
            prefixIcon: Icon(Icons.lock),
            labelText: "密码",
            hintText: "您的登录密码",
            hintStyle: TextStyle(color: Colors.grey, fontSize: 13.0)
        ),
        obscureText: true,
      )
    ],
  )
)
</code></pre>
<p>运行效果如图3-22所示：</p>
<p><img src="../imgs/3-22.png" alt="图3-22" /></p>
<p>我们成功的自定义了下划线颜色和提问文字样式，细心的读者可能已经发现，通过这种方式自定义后，输入框在获取焦点时，<code>labelText</code>不会高亮显示了，正如上图中的"用户名"本应该显示蓝色，但现在却显示为灰色，并且我们还是无法定义下划线宽度。另一种灵活的方式是直接隐藏掉<code>TextField</code>本身的下划线，然后通过<code>Container</code>去嵌套定义样式，如:</p>
<pre><code class="language-dart">Container(
  child: TextField(
    keyboardType: TextInputType.emailAddress,
    decoration: InputDecoration(
        labelText: "Email",
        hintText: "电子邮件地址",
        prefixIcon: Icon(Icons.email),
        border: InputBorder.none //隐藏下划线
    )
  ),
  decoration: BoxDecoration(
      // 下滑线浅灰色，宽度1像素
      border: Border(bottom: BorderSide(color: Colors.grey[200], width: 1.0))
  ),
)
</code></pre>
<p>运行效果如图3-23：</p>
<p><img src="../imgs/3-23.png" alt="3-23" /></p>
<p>通过这种组件组合的方式，也可以定义背景圆角等。一般来说，优先通过<code>decoration</code>来自定义样式，如果<code>decoration</code>实现不了，再用widget组合的方式。</p>
<blockquote>
<p>思考题：在这个示例中，下划线颜色是固定的，所以获得焦点后颜色仍然为灰色，如何实现点击后下滑线也变色呢？</p>
</blockquote>
<h2 id="352-表单form"><a class="header" href="#352-表单form">3.5.2 表单Form</a></h2>
<p>实际业务中，在正式向服务器提交数据前，都会对各个输入框数据进行合法性校验，但是对每一个<code>TextField</code>都分别进行校验将会是一件很麻烦的事。还有，如果用户想清除一组<code>TextField</code>的内容，除了一个一个清除有没有什么更好的办法呢？为此，Flutter提供了一个<code>Form</code> 组件，它可以对输入框进行分组，然后进行一些统一操作，如输入内容校验、输入框重置以及输入内容保存。</p>
<h3 id="1-form"><a class="header" href="#1-form">1. Form</a></h3>
<p><code>Form</code>继承自<code>StatefulWidget</code>对象，它对应的状态类为<code>FormState</code>。我们先看看<code>Form</code>类的定义：</p>
<pre><code class="language-dart">Form({
  required Widget child,
  bool autovalidate = false,
  WillPopCallback onWillPop,
  VoidCallback onChanged,
})
</code></pre>
<ul>
<li><code>autovalidate</code>：是否自动校验输入内容；当为<code>true</code>时，每一个子 FormField 内容发生变化时都会自动校验合法性，并直接显示错误信息。否则，需要通过调用<code>FormState.validate()</code>来手动校验。</li>
<li><code>onWillPop</code>：决定<code>Form</code>所在的路由是否可以直接返回（如点击返回按钮），该回调返回一个<code>Future</code>对象，如果 Future 的最终结果是<code>false</code>，则当前路由不会返回；如果为<code>true</code>，则会返回到上一个路由。此属性通常用于拦截返回按钮。</li>
<li><code>onChanged</code>：<code>Form</code>的任意一个子<code>FormField</code>内容发生变化时会触发此回调。</li>
</ul>
<h3 id="2-formfield"><a class="header" href="#2-formfield">2. FormField</a></h3>
<p><code>Form</code>的子孙元素必须是<code>FormField</code>类型，<code>FormField</code>是一个抽象类，定义几个属性，<code>FormState</code>内部通过它们来完成操作，<code>FormField</code>部分定义如下：</p>
<pre><code class="language-dart">const FormField({
  ...
  FormFieldSetter&lt;T&gt; onSaved, //保存回调
  FormFieldValidator&lt;T&gt;  validator, //验证回调
  T initialValue, //初始值
  bool autovalidate = false, //是否自动校验。
})
</code></pre>
<p>为了方便使用，Flutter 提供了一个<code>TextFormField</code>组件，它继承自<code>FormField</code>类，也是<code>TextField</code>的一个包装类，所以除了<code>FormField</code>定义的属性之外，它还包括<code>TextField</code>的属性。</p>
<h3 id="3-formstate"><a class="header" href="#3-formstate">3. FormState</a></h3>
<p><code>FormState</code>为<code>Form</code>的<code>State</code>类，可以通过<code>Form.of()</code>或<code>GlobalKey</code>获得。我们可以通过它来对<code>Form</code>的子孙<code>FormField</code>进行统一操作。我们看看其常用的三个方法：</p>
<ul>
<li><code>FormState.validate()</code>：调用此方法后，会调用<code>Form</code>子孙<code>FormField的validate</code>回调，如果有一个校验失败，则返回false，所有校验失败项都会返回用户返回的错误提示。</li>
<li><code>FormState.save()</code>：调用此方法后，会调用<code>Form</code>子孙<code>FormField</code>的<code>save</code>回调，用于保存表单内容</li>
<li><code>FormState.reset()</code>：调用此方法后，会将子孙<code>FormField</code>的内容清空。</li>
</ul>
<h3 id="4-示例"><a class="header" href="#4-示例">4. 示例</a></h3>
<p>我们修改一下上面用户登录的示例，在提交之前校验：</p>
<ol>
<li>用户名不能为空，如果为空则提示“用户名不能为空”。</li>
<li>密码不能少于 6 位，如果小于 6 为则提示“密码不能少于 6 位”。</li>
</ol>
<p>完整代码：</p>
<pre><code class="language-dart">import 'package:flutter/material.dart';

class FormTestRoute extends StatefulWidget {
  @override
  _FormTestRouteState createState() =&gt; _FormTestRouteState();
}

class _FormTestRouteState extends State&lt;FormTestRoute&gt; {
  TextEditingController _unameController = TextEditingController();
  TextEditingController _pwdController = TextEditingController();
  GlobalKey _formKey = GlobalKey&lt;FormState&gt;();

  @override
  Widget build(BuildContext context) {
    return Form(
      key: _formKey, //设置globalKey，用于后面获取FormState
      autovalidateMode: AutovalidateMode.onUserInteraction,
      child: Column(
        children: &lt;Widget&gt;[
          TextFormField(
            autofocus: true,
            controller: _unameController,
            decoration: InputDecoration(
              labelText: "用户名",
              hintText: "用户名或邮箱",
              icon: Icon(Icons.person),
            ),
            // 校验用户名
            validator: (v) {
              return v!.trim().isNotEmpty ? null : "用户名不能为空";
            },
          ),
          TextFormField(
            controller: _pwdController,
            decoration: InputDecoration(
              labelText: "密码",
              hintText: "您的登录密码",
              icon: Icon(Icons.lock),
            ),
            obscureText: true,
            //校验密码
            validator: (v) {
              return v!.trim().length &gt; 5 ? null : "密码不能少于6位";
            },
          ),
          // 登录按钮
          Padding(
            padding: const EdgeInsets.only(top: 28.0),
            child: Row(
              children: &lt;Widget&gt;[
                Expanded(
                  child: ElevatedButton(
                    child: Padding(
                      padding: const EdgeInsets.all(16.0),
                      child: Text("登录"),
                    ),
                    onPressed: () {
                      // 通过_formKey.currentState 获取FormState后，
                      // 调用validate()方法校验用户名密码是否合法，校验
                      // 通过后再提交数据。
                      if ((_formKey.currentState as FormState).validate()) {
                        //验证通过提交数据
                      }
                    },
                  ),
                ),
              ],
            ),
          )
        ],
      ),
    );
  }
}
</code></pre>
<p>运行后效果如图3-24所示：</p>
<p><img src="../imgs/3-24.png" alt="图3-24" /></p>
<p>注意，登录按钮的<code>onPressed</code>方法中不能通过<code>Form.of(context)</code>来获取<code>FormState</code>，原因是，此处的<code>context</code>为<code>FormTestRoute</code>的context，而<code>Form.of(context)</code>是根据所指定<code>context</code>向根去查找，而<code>FormState</code>是在<code>FormTestRoute</code>的子树中，所以不行。正确的做法是通过<code>Builder</code>来构建登录按钮，<code>Builder</code>会将<code>widget</code>节点的<code>context</code>作为回调参数：</p>
<pre><code class="language-dart">Expanded(
 // 通过Builder来获取ElevatedButton所在widget树的真正context(Element) 
  child:Builder(builder: (context){
    return ElevatedButton(
      ...
      onPressed: () {
        //由于本widget也是Form的子代widget，所以可以通过下面方式获取FormState  
        if(Form.of(context).validate()){
          //验证通过提交数据
        }
      },
    );
  })
)
</code></pre>
<p>其实<code>context</code>正是操作Widget所对应的<code>Element</code>的一个接口，由于Widget树对应的<code>Element</code>都是不同的，所以<code>context</code>也都是不同的，有关<code>context</code>的更多内容会在本书后面进阶篇中详细讨论。Flutter中有很多“of(context)”这种方法，读者在使用时一定要注意<code>context</code>是否正确。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapter3/radio_and_checkbox.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chapter3/progress.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapter3/radio_and_checkbox.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chapter3/progress.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
